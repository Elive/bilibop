bilibop-rules
-------------

1. OVERVIEW
===========

This package mainly provides a udev rules file to be applied on operating
systems running from external media (USB stick, USB HDD, FireWire, Flash
Memory stick, eSATA HDD). Its goal is to adapt some system behaviours to
its particular situation, like an organ outside of the body. Bilibop-rules
is based on the bilibop-common functions and need Linux kernel 2.6.37 or
higher to work properly.

The running system being hosted on a removable device, the common udev
rules (91-permissions.rules) will set it as owned by the 'floppy' group,
allowing any member of this group to damage it, even by mistake, with a
simple 'shred DEVICE' or 'cat /dev/zero >DEVICE' command. So the bilibop
rules fix the disk hosting the operating system and all its partitions as
owned by the 'disk' group, as it was an internal disk. This is the main,
and this is not optional.


2. OTHER UDEV RULES
===================

Another feature of the bilibop udev rules is to tag all devices hosted by
the same disk than the root filesystem as 'BILIBOP'. This applies to all
physical devices (disk and partitions) and virtual devices (device-mapper
and loop), and can be used later by the lsbilibop(8) command (see below).

Internal physical block devices (i.e. disks and partitions of the drives
inside the computer) are also tagged as 'INSIDEV'. This can be used later
by the physical_volumes_filter helper script, and provides an easy way to
customize the settings and behaviour of these internal devices (see
90-insidev.rules in the documentation of the package for examples).

Additionally, if one of the 'BILIBOP' tagged devices uses the device-mapper,
some of the udev symlinks to this device are updated. This is done because
when a device has already been added from the initrd, the dm rules file
(55-dm.rules) makes that the spurious 'add' uevent triggered by udev from
the system environment don't update symlinks to the added device, leading
to this situation, that a dm device can have a lot of symlinks created by
udev in the initrd environment, but none is managed by udev in the system
environment. So, bilibop rules restore at least /dev/mapper/dm_name as a
part of the udev database, and also /dev/vg_name/lv_name if the device is
a Logical Volume.


2.1. Udisks facilities
----------------------

Bilibop rules include rules to set udisks(7) environment variables for
the devices hosted on the same disk than the root filesystem. If one of
the Gnome, KDE, Xfce or LXDE desktop environment is installed, and then
Udisks is used to mount/unmount removable devices from the file manager
or the desktop (which is an instance of the file manager), it is possible
to hide some devices, or show them with a different name or icon than the
default, or prompt the user for su/sudo password when she attempts to
manage them. The udisks variables bilibop rules can set are:

UDISKS_PRESENTATION_HIDE
UDISKS_PRESENTATION_NAME
UDISKS_PRESENTATION_ICON_NAME
UDISKS_SYSTEM_INTERNAL

By default, 'BILIBOP' tagged devices are hidden and set 'system internal'.

The rule ENV{ID_DRIVE_DETACHABLE}:=0 is also applied to the disk, to avoid
udisks detach it from its bus when a partition is unmounted, but it seems
to not work correctly. Bad thing! Here the Udisks ability to detach a drive
can lead to crash the system :(


2.2. lsbilibop
--------------

This command can be used to list 'BILIBOP' tagged devices, and display or
update some of their udev properties. It should be used each time the
BILIBOP_RULES_* variables are modified in /etc/bilibop/bilibop.conf.

See the bilibop.conf(5) and lsbilibop(8) manual pages and
/usr/share/doc/bilibop-rules/examples/bilibop.conf
for detailed information about default or custom settings.


3. HELPER SCRIPTS
=================

bilibop-rules provides helper scripts (in /usr/share/bilibop). Two of them
are run from the maintainer scripts (postinst and prerm) but all can be
ran manually by the admin. Each of them accepts the '--help' option, to know
how to use it.

If BILIBOP_COMMON_BASENAME is modified in bilibop.conf(5), then at least
'make_unpersistent_rules' and 'grub_device_map_manager' must be executed
to make some symlinks to reflect the new setting. 'bilibop_rules_generator'
must be executed again, if it has been used previously to generate a custom
rules file.


3.1. bilibop_rules_generator
----------------------------

This program generates a udev rules file /etc/udev/rules.d/66-bilibop.rules
doing the same things than the file with the same name in /lib/udev/rules.d.
The main difference is that rules in /lib are generic and can take more time
if a lot of removable devices are plugged onto the computer. Rules in /etc
use the sysfs attributes of the device hosting the system and run faster.

Take care that if your device is able to be plugged on several port types
(i.e. can be used both as USB and FireWire, or USB and eSATA, or MMC and USB
- by using an adapter) the generated rules will work only for the interface
type on which it was plugged when the rules have been generated. As example,
for a 'LaCie Rugged FW/USB' external HDD:

3.1.a. When booted as USB device

The sysfs attributes possibly managed by the script are:
ATTRS{vendor}=="LaCie   "
ATTRS{model}=="Rugged FW/USB   "
...
ATTRS{manufacturer}=="LaCie"
ATTRS{product}=="LaCie Rugged FW/USB"
ATTRS{serial}=="00D04B9A0506232D"

3.1.b. When booted as FireWire device

The sysfs attributes possibly managed by the script are:
ATTRS{vendor}=="LaCie   "
ATTRS{model}=="Rugged FW/USB   "

3.1.c. Generate the proper rules file:

To generate a rules files matching sysfs attributes both for USB and FireWire
usage, you have to force 'vendor' and 'model' sysfs attributes, because the
default being to use 'manufacturer', 'product' and 'serial' if they exist, as
they don't exist when the disk is plugged on FireWire, the rules working fine
for USB will not work for FireWire. So, use this command:

/usr/share/bilibop/bilibop_rules_generator --attribute vendor,model


3.2. grub_device_map_manager
----------------------------

This program can be used in association with BILIBOP_RULES_FAKE_DEVICE_MAP
variable to set the location and contents of the GRUB device.map. The
standard path of this file is /boot/grub/device.map; its content is
generally written the first time 'update-grub' is run. After what it can
be considered as a static file with a static content. But when the system
runs from a removable drive on a different computer than during its
installation, update-grub can complain and fail because the drives actually
connected to the computer don't match the device map created in other
conditions.

To avoid that, it is possible - and highly recommended - to use either an
always-up-to-date device map, or a fake one. It is the goal of this helper
script. It is run when the package is installed to modify either the location
of /boot/grub/device.map or its content. If device.map already is a symlink,
it is replaced by a new symlink to /run/bilibop/grub-device.map; otherwise
its content is modified to map the system drive as the first disk (hd0).

As for 'bilibop_rules_generator', if you plan to plug the drive hosting
your system on different interfaces (USB, FireWire, etc.), it is not
recommended to use a static fake device map. On the other hand, the use
of a symlink can imply to run the script if BILIBOP_COMMON_BASENAME has
been modified in bilibop.conf(5).


3.3. make_unpersistent_rules
----------------------------

This program replaces some persistent and cumulative rules files in
/etc/udev/rules.d by symlinks to unpersistent and always-up-to-date files
in /run/bilibop. It is run during the installation of the package to do
that, and when it is removed, to undo that. There is no need to play with
this program, except when BILIBOP_COMMON_BASENAME has been modified in
bilibop.conf.


3.4. physical_volumes_filter
----------------------------

This script can be used to display the LVM 'filter' settings actually in
use, or to modify these settings. It uses the 'BILIBOP' and 'INSIDEV' tags
to find devices and their symlinks and build patterns on which the 'accept'
or 'reject' behaviours will be applied.

For example, if you don't want to activate Logical Volumes other than those
used by your system, you can easily make that all Physical Volumes that are
not used by your system are ignored and never scanned by lvm tools:

/usr/share/bilibop/physical_volumes_filter --overwrite --udev --accept bilibop --reject all

Or, shorter:

/usr/share/bilibop/physical_volumes_filter -oua bilibop -r all.

This can be very useful, especially when the VG and LV names used on your
system are as generic as 'vg0' and 'lv0', 'lv1', etc.

One time you are satisfied of your settings, you should not modify them.
To use other LVM filters without modifying your owns, you can do:

# mkdir /tmp/lvm
# cp /etc/lvm/lvm.conf /tmp/lvm
# export LVM_SYSTEM_DIR=/tmp/lvm

And then you can use 'pvfilter' and all LVM tools from the same shell:
changes from pvfilter will apply to /tmp/lvm/lvm.conf, and LVM tools will
use the settings from this temporary file. If, for a reason or another,
the initramdisk of your system is updated during this time, lvm.conf
will be copied in it from /etc/lvm, not from /tmp/lvm, and so your next
boot will not be compromised. In this context, you can safely run:

/usr/share/bilibop/physical_volumes_filter --overwrite --blank --reject bilibop --show

And then you can perform operations on Physical or Logical Volumes by
using LVM commands without take the risk to modify your owns by mistake.

See also lvm.conf(5) manual page for details.


4. MORE INFO
============

See /usr/share/doc/bilibop-common/misc/*


 -- bilibop project <quidame@poivron.org>  Tue, 17 Apr 2012 03:03:52 +0200
 -- bilibop project <quidame@poivron.org>  Wed, 19 Dec 2012 22:51:56 +0100
