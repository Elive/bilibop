# /lib/udev/rules.d/66-bilibop.rules
#
# Do not edit this file, it will be overwritten on updates. Instead,
# you can run /usr/share/bilibop/bilibop_rules_generator to create a
# (pre)customized sample /etc/udev/rules.d/66-bilibop.rules, and modify
# it if necessary.

# Process only on some block devices:
SUBSYSTEM!="block", GOTO="bilibop_end"
KERNEL=="dm-?*|loop?*", GOTO="bilibop_virtual_block"
KERNEL!="sd?*|mmcblk?*|mspblk?*", GOTO="bilibop_end"

# For the resulting block devices, skip all that is not USB, FireWire or Flash
# Memory cards, and test if the device is hosted by the same disk than the root
# filesystem. If yes, fix its group to 'disk' (this is mandatory), add a tag,
# go to a xxx label to continue...
ACTION=="add|change", \
	SUBSYSTEMS=="usb|firewire|memstick|mmc", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	GROUP:="disk", \
	TAG+="BILIBOP", \
	GOTO="bilibop_rules"

# ...and let all the rest go directly to the end.
GOTO="bilibop_end"
LABEL="bilibop_rules"

# Create a symlink pointing to the disk node, add an environment variable,
# and optionally write a fake grub device map:
ACTION=="add|change", \
	KERNEL=="sd?|mmcblk?|mspblk?", \
	PROGRAM=="bilibop_disk --disk %r/%k", \
	SYMLINK+="%c", \
	ENV{BILIBOP_DISK}="%r/%k", \
	GOTO="bilibop_end"

# Add an environment variable for the partitions:
ACTION=="add|change", \
	ATTR{partition}=="?*", \
	ENV{BILIBOP_PARTITION}="%r/%k"

# Now process on loopback and mapped devices. If they are hosted by the same
# disk than the root filesystem, add their parent partition's name to the
# udev database:
LABEL="bilibop_virtual_block"

ACTION=="add|change", \
	KERNEL=="loop?*", \
	TEST=="loop/backing_file", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	PROGRAM=="bilibop_disk --part %r/%k", \
	ENV{BILIBOP_UNDERLYING_PARTITION}="%c", \
	TAG+="BILIBOP"

ACTION=="add|change", \
	KERNEL=="dm-?*", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	PROGRAM=="bilibop_disk --part %r/%k", \
	ENV{BILIBOP_UNDERLYING_PARTITION}="%c", \
	TAG+="BILIBOP"

# Add two other symlinks: one targetting the underlying partition (host) and
# the other targetting the root filesystem (root).
ACTION=="add|change", \
	TAG=="BILIBOP", \
	PROGRAM=="bilibop_disk --root %r/%k", \
	SYMLINK+="%c"

# Due to the bilibop configuration file, based on ID_FS_* udev variables, we
# need additional information here, and we want to be sure this information
# is available for the next rules. Additionnaly, drivemap(1) and lsbilibop(8)
# commands can need to query ID_FS_* values, even if udisks is not installed.
ACTION=="add|change", \
	TAG=="BILIBOP", \
	ENV{ID_FS_USAGE}=="", \
	IMPORT{program}="/sbin/blkid -o udev -p %r/%k"

# Now there is only partitions and virtual block devices hosted on the bilibop
# disk to process. And the following rules are for the desktop environment;
# they make sense only if Udisks is installed:
TAG=="BILIBOP", \
	TEST=="/lib/udev/rules.d/80-udisks.rules", \
	GOTO="bilibop_udisks"

# Nothing else to do for other devices or if udisks rules file was not found:
GOTO="bilibop_end"

LABEL="bilibop_udisks"

ACTION=="add|change", \
	PROGRAM=="bilibop_disk --lock %r/%k", \
	ENV{UDISKS_SYSTEM_INTERNAL}:="1"

ACTION=="add|change", \
	PROGRAM=="bilibop_disk --hide %r/%k", \
	ENV{UDISKS_PRESENTATION_HIDE}:="1", \
	GOTO="bilibop_end"

# If the device is hidden to the user, there is no need to set its presentation
# icon nor its name.

ACTION=="add|change", \
	PROGRAM=="bilibop_disk --icon %r/%k", \
	ENV{UDISKS_PRESENTATION_ICON_NAME}:="%c"

ACTION=="add|change", \
	PROGRAM=="bilibop_disk --name %r/%k", \
	ENV{UDISKS_PRESENTATION_NAME}:="%c"

LABEL="bilibop_end"
