#!/bin/sh

# /lib/bilibop/lockfs_mount_helper
# Mount helper script for 'lockfs' filesystem type entries in /etc/fstab.
# This script cannot be run manually. The expected way to run it is the
# following:
# 1. Enable bilibop-lockfs:
#    * set BILIBOP_LOCKFS to "true" in /etc/bilibop/bilibop.conf or
#    * append 'lockfs' parameter in the boot commandline
# 2. One time '/' is an aufs mountpoint, the temporary /etc/fstab is
#    modified to replace filesystem types (third field) of some entries
#    by 'lockfs' (options are modified too to remember the original
#    fstype).
# 3. /sbin/mount.lockfs is created if it don't already exist. This can be a
#    symlink to /lib/bilibop/lockfs_mount_helper if this helper is executable,
#    or a copy of the helper (followed by chmod +x) if the helper is not
#    executable. If the helper is missing, /sbin/mount.lockfs will be a
#    poor fallback to call mount normally.
# 4. /etc/fstab is parsed by 'mount -a', and then mount calls mount.lockfs
#    with the proper arguments when a 'lockfs' fstype is encountered.

PATH="/sbin:/bin"

usage() {
	cat <<EOF
${0##*/}: mount helper script for bilibop-lockfs.
This script can not be run manually, but only by a mount process.
EOF
}

# Works only if the parent process is /bin/mount:
if	[ "$(readlink -f /proc/${PPID}/exe)" != "/bin/mount" ]
then	usage >&2
	exit 3
fi


. /lib/bilibop/lockfs.sh
get_udev_root

# Works only if the root filesystem is already managed by bilibop-lockfs:
if	is_aufs_mountpoint -q / && [ -f "${BILIBOP_RUNDIR}/lock" ]
then
	LOCKFS="true"
	robr="$(aufs_readonly_branch /)"
	rwbr="$(aufs_writable_branch /)"
else
	echo "${0##*/}: bilibop-lockfs is disabled." >&2
	exit 1
fi


# Parse arguments. We need to know the device to mount, the mountpoint and the
# mount options:
while	[ "${1}" ]
do
	case	"${1}" in
		${udev_root}/*)
			[ -b "${1}" ] && device="${1}"
			shift
			;;
		/*)
			[ -d "${1}" ] && mntpnt="${1%/}"
			shift
			;;
		-o)
			options="${2}"
			shift 2
			;;
		*)
			usage >&2
			exit 1
			;;
	esac
done

if	[ -b "${device}" ]
then
	# Query ID_FS_* udev environment variables of the device:
	eval $(query_udev_envvar $(readlink -f ${device}))
	if	[ -z "${ID_FS_USAGE}" ]
	then	eval $(blkid -o udev -p ${device})
	fi
else
	# There is no block device to mount. Maybe it is a bind mount of
	# a directory on another, or whatever...
	LOCKFS="false"
fi

# Skip whitelisted device (those using the mountpoint have been treated by the
# initramfs script):
for	skip in ${BILIBOP_LOCKFS_WHITELIST}
do
	case	"${skip}" in
		UUID=${ID_FS_UUID}|LABEL=${ID_FS_LABEL}|TYPE=${ID_FS_TYPE})
			LOCKFS="false"
			;;
	esac
done


# Parse mount options. Two cases:
# 1. the block device will be mounted with the same options than in the
#    original fstab entry, plus 'ro'.
# 2. the tmpfs will be mounted with only some options of the previous:
#    ro, nodev, noexec, nosuid, if they exist.

# 1. Options for the readonly branch:
for	opt in $(IFS=',' ; echo ${options})
do
	case	"${opt}" in
		fstype=*)
			eval "${opt}"
			;;
		rw)
			;;
		*)
			robr_opts="${robr_opts:+${robr_opts},}${opt}"
			;;
	esac
done

# 2. Options for the writable branch:
for	opt in $(IFS=',' ; echo ${options})
do
	case	"${opt}" in
		ro|nodev|noexec|nosuid)
			rwbr_opts="${rwbr_opts:+${rwbr_opts},}${opt}"
			;;
		*)
			;;
	esac
done


# If bilibop-lockfs is not enabled (the device is whitelisted), rewrite the
# fstab entry and do a normal mount:
if	[ "${LOCKFS}" != "true" ]
then
	mount_fallback "${device}" "${mntpnt}" "${fstype}" "${robr_opts}"
	exit $?
fi


# Each readonly branch is mounted under the subtree of the main readonly
# branch (/aufs/ro) and each writable branch is mounted under the subtree
# of the main writable branch:
robr="${robr}${mntpnt}"
rwbr="${rwbr}${mntpnt}"


# If the policy is not explicitly set to 'soft', set the block device as
# readonly, and use 'rr' aufs option to improve performances:
if	[ "${BILIBOP_LOCKFS_POLICY}" = "soft" ]
then
	RO="ro"
else
	RO="rr"
	blockdev --setro ${device}
fi

# Try to mount the readonly branch. In case of failure, undo what has been
# done before, do a normal mount, rewrite the fstab entry to be coherent
# with that, and exit:
if	! mount ${fstype:+-t ${fstype}} -o ${robr_opts:+${robr_opts},}ro ${device} ${robr}
then
	[ "${RO}" = "rr" ] && blockdev --setrw "${device}"
	mount_fallback "${device}" "${mntpnt}" "${fstype}" "${robr_opts}"
	exit 3
fi

# The amount of RAM to allow to this mountpoint:
SIZE=
for	size in ${BILIBOP_LOCKFS_SIZE}
do
	case	"${size}" in
		${mntpnt}=[0-9]*[0-9KkMmGg%])
			SIZE="${size#${mntpnt}=}"
			break
			;;
	esac
done

# Create the mountpoint (it should not exist before this step):
[ ! -d "${rwbr}" ] &&
	mkdir -p ${rwbr} &&
	lock_file "${mntpnt}"

# Try to mount the writable branch, and in case of failure, undo what
# has been done before, etc.
if	! mount -t tmpfs -o ${rwbr_opts:+${rwbr_opts},}${SIZE:+size=${SIZE},}mode=0755 tmpfs ${rwbr}
then
	umount ${robr}
	[ "${RO}" = "rr" ] && blockdev --setrw "${device}"
	mount_fallback "${device}" "${mntpnt}" "${fstype}" "${robr_opts}"
	exit 3
fi


# Fix permissions and ownership of the writable branch (and catch the values;
# they will be reused later):

mod="$(chmod -v --reference="${robr}" "${rwbr}" | sed 's;.* \([0-7]\{4\}\) (.\+);\1;')"
own="$(chown -v --reference="${robr}" "${rwbr}" | sed 's;.* \([^: ]\+:[^: ]\+\)$;\1;')"

owner="${own%:*}"
if	[ "${owner}" != "root" ]
then	uid="$(grep "^${owner}:" /etc/passwd | sed 's;^\([^:]*:\)\{2\}\([^:]\+\):.*;\2;')"
fi

group="${own#*:}"
if	[ "${group}" != "root" ]
then	gid="$(grep "^${group}:" /etc/group | sed 's;^\([^:]*:\)\{2\}\([^:]\+\):.*;\2;')"
fi


# Try to mount the aufs now. In case of failure, undo what has been done
# before, etc.
if	! mount -t aufs -o br:${rwbr}=rw:${robr}=${RO} none ${mntpnt}
then
	umount ${robr}
	umount ${rwbr}
	[ "${RO}" = "rr" ] && blockdev --setrw "${device}"
	mount_fallback "${device}" "${mntpnt}" "${fstype}" "${robr_opts}"
	exit 3
fi


# All is OK. So we can rewrite fstab entry to reflect the real mounts. This
# can be important for clean unmounts at shutdown (for the case a filesystem
# is remounted rw during a session).
robr_line="${device} ${robr} ${fstype:-auto} ${robr_opts:+${robr_opts},}ro 0 0"
rwbr_line="tmpfs ${rwbr} tmpfs ${rwbr_opts:+${rwbr_opts},}${SIZE:+size=${SIZE},}${uid:+${uid},}${gid:+${gid},}mode=${mod} 0 0"
aufs_line="none ${mntpnt} aufs br:${rwbr}=rw:${robr}=${RO} 0 0"

sed -i "s;^\s*[^#][^ ]\+\s\+${mntpnt}\s\+lockfs\s.*;${rwbr_line}\n${robr_line}\n${aufs_line};" /etc/fstab


