#!/bin/sh
set -e

# /usr/share/bilibop/make_unpersistent_rules

# Remove some persistent udev rules files (cd & net) and replace them by links
# to unpersistent files (in /run/bilibop); ...or restore them.
# This is made because these persistent rules files are cumulative, and so are
# not very adapted for an operating system on external hard disk or usb key.

### BEGIN ###

PATH="/sbin:/bin:/usr/bin"
PROG="${0##*/}"

. /lib/bilibop/common.sh

#get_udev_root
get_bilibop_variables

ETC_RULES_DIR="/etc/udev/rules.d"
restore=""
verbose=""
only=""
TYPE=""
SKIP=""

usage() {
	cat <<EOF
${PROG} replaces some persistent udev rules files by
links to unpersistent files (in ${BILIBOP_RUNDIR}).
This is done to avoid cumulative informations about optical drives
and network interfaces.

Usage: ${PROG} [OPTIONS]

OPTIONS:
  -h, --help
      Display this help and exit.

  -o TYPE, --only TYPE
      Apply actions only for the specified TYPE of rules (cd or net).

  -r, --restore
      Remove links to unpersistent rules files and restore persistent
      (static) udev rules files.

  -v, --verbose
      Be verbose.
EOF
}

execute() {
	if [ -n "${verbose}" ]; then
		echo "> ${@}"
	fi
	"${@}"
}


set +e
# Parse options.
ARGS="$(getopt -o ho:rv --long help,only:,restore,verbose -n "${PROG}" -- "${@}")"

if [ "${?}" != "0" ]; then
	usage >&2
	exit 1
else
	eval set -- "${ARGS}"
fi
set -e


while true; do
	case "${1}" in
		-h|--help)
			usage
			exit 0
			;;
		-o|--only)
			only="${2}"
			shift 2
			;;
		-r|--restore)
			restore="true"
			shift
			;;
		-v|--verbose)
			verbose="-v"
			shift
			;;
		--)
			shift
			break
			;;
		*)
			unknown_argument "${1}" >&2
			usage >&2
			exit 1
			;;
	esac
done

# Now, analyse the results.
case "${only}" in
	cd)
		TYPE="cd"
		SKIP="net"
		;;
	net)
		TYPE="net"
		SKIP="cd"
		;;
	"")
		TYPE="cd net"
		SKIP=""
		;;
	*)
		unknown_argument "${only}" >&2
		exit 1
		;;
esac

make_regular() {
	persistent="${ETC_RULES_DIR}/70-persistent-${i}.rules"
	if [ -h "${persistent}" ]; then
		unpersistent="$(readlink -f ${persistent})"
		execute rm ${verbose} ${persistent}
		if [ -f "${unpersistent}" ]; then
			execute mv ${verbose} ${unpersistent} ${persistent}
		else
			execute touch ${persistent}
		fi

	elif [ ! -f "${persistent}" ]; then
		unpersistent="${BILIBOP_RUNDIR}/unpersistent-${i}.rules"
		if [ -f "${unpersistent}" ]; then
			execute mv ${verbose} ${unpersistent} ${persistent}
		else
			execute touch ${persistent}
		fi
	fi
}

make_symlink() {
	persistent="${ETC_RULES_DIR}/70-persistent-${i}.rules"
	unpersistent="${BILIBOP_RUNDIR}/unpersistent-${i}.rules"
	if [ -h "${persistent}" ]; then
		target="$(readlink -f ${persistent})"
		if	[ "${target}" = "${unpersistent}" ]; then
			[ -f "${target}" ] || execute touch ${target}
			# nothing else to do:
			continue
		else
			[ -f "${target}" ] && execute mv ${verbose} ${target} ${unpersistent}
		fi

	elif [ -f "${persistent}" ]; then
		execute mv ${verbose} ${persistent} ${unpersistent}
	fi

	[ -e "${persistent}" ] && execute rm ${verbose} ${persistent}
	[ -e "${unpersistent}" ] || execute touch ${unpersistent}
	execute ln -s ${verbose} ${unpersistent} ${persistent}
}

# And run...
if [ "${restore}" = "true" ]; then
	for	i in ${TYPE}; do
		make_regular ${i}
	done
	for	i in ${SKIP}; do
		make_symlink ${i}
	done

else
	if [ ! -d "${BILIBOP_RUNDIR}" ]; then
		execute mkdir -p ${BILIBOP_RUNDIR}
	fi
	for	i in ${TYPE}; do
		make_symlink ${i}
	done
	for	i in ${SKIP}; do
		make_regular ${i}
	done
fi

### END ###
# vim: ts=4 sts=4 sw=4
